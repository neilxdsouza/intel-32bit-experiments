This project is a list of my tinkering with the 32 bit i386 and above CPUs
Each program is simple and builds on the previous one incrementally


make_floppy.c: this file creates a floppy disk sized image. We will write our
binary programs to this floppy and use an emulator to see the result.

Emulators: bochs has excellent debugging support:
The lines below marked by ---- are from the bochs manual. Refer to the chapter
"Using the Bochs internal debugger"
------------------
To use the debugger, you must configure Bochs with the --enable-debugger and --enable-disasm flags. For example:
  ./configure --enable-debugger --enable-disasm
------------------
You can also use qemu.

I run bochs this way:
/usr/bochs2.3/bin/bochs -q 'boot:a' 'floppya: 1_44=floppy.img, status=inserted'

-----------------------------------------------------------------
prin-v0.asm
prin-part2.asm
Objective: prin-v0.asm is a 1st stage loader - it prints a message on the screen 
and loads a 2nd program into memory(prin-part2.asm) and executes it.

To understand how prin-v0.asm works you need to download Ralf Brown's interrupt list
which documents almost all known BIOS interrupts, int 13h reads from a disk.

prin-part2.asm contains certain routines like scroll_screen etc - but they 
have not been debugged or tested yet. The make target for this pair of files is
"prinv0boot"
i.e. execute make prinv0boot and then (I) run this in the simulator as:
/usr/bochs2.3/bin/bochs -q 'boot:a' 'floppya: 1_44=floppy.img, status=inserted'

I looked at at least the following projects when writing this
1. Daniel Majarmaki's nasmboot.txt
2. JOS kernel boot.S which is used in an OS course by MIT, UCLA and Univ of Washington.
   It seems to have the simplest jump to 32 bit mode
3. www.brokenthorn.com - OS tutorial
---------------------------------------------------------------
