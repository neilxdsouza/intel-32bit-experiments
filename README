This project is a list of my tinkering with the 32 bit i386 and above CPUs
Each program is simple and builds on the previous one incrementally


make_floppy.c: this file creates a floppy disk sized image. We will write our
binary programs to this floppy and use an emulator to see the result.

Emulators: bochs has excellent debugging support:
The lines below marked by ---- are from the bochs manual. Refer to the chapter
"Using the Bochs internal debugger"
------------------
To use the debugger, you must configure Bochs with the --enable-debugger and --enable-disasm flags. For example:
  ./configure --enable-debugger --enable-disasm
------------------
You can also use qemu.

I run bochs this way:
/usr/bochs2.3/bin/bochs -q 'boot:a' 'floppya: 1_44=floppy.img, status=inserted'

-----------------------------------------------------------------
prin-v0.asm
prin-part2.asm
Objective: prin-v0.asm is a 1st stage loader - it prints a message on the screen 
and loads a 2nd program into memory(prin-part2.asm) and executes it.

To understand how prin-v0.asm works you need to download Ralf Brown's interrupt list
which documents almost all known BIOS interrupts, int 13h reads from a disk.

prin-part2.asm contains certain routines like scroll_screen etc - but they 
have not been debugged or tested yet. The make target for this pair of files is
"prinv0boot"
i.e. execute make prinv0boot and then (I) run this in the simulator as:
/usr/bochs2.3/bin/bochs -q 'boot:a' 'floppya: 1_44=floppy.img, status=inserted'

I looked at at least the following projects when writing this
1. Daniel Majarmaki's nasmboot.txt
2. JOS kernel boot.S which is used in an OS course by MIT, UCLA and Univ of Washington.
   It seems to have the simplest jump to 32 bit mode
3. www.brokenthorn.com - OS tutorial
---------------------------------------------------------------


---------------------------------------------------
Makefile Target: prinv1boot
Source Files: prin-v0.asm prin2-part2.asm
Objective: Consolidate what has been developed above. 
Print to the screen without using the BIOS int 10h. When we 
switch to 32 bit mode we cannot use BIOS interrupts, so we need to write to
the video memory directly and update the cursor position ourselves.
When writing to video memory I realised that bochs does not update the 
screen if you do not update the cursor. Scroll the screen ourselves.

My learnings in this :
1. you cant mix int 10h and writing to video mem directly - 
   int 10h seems to have its own internal location of where the cursor is
   so if you write to video memory first and then use 10h to state that this
   was successful, int 10h will overwrite your text string and you will not 
   see it on screen.
2. I got scroll_screen working on this and it was beautiful to see the 
   rep movsw function work to scroll the screen.

I studied the JOS code in console.c to understand how this is done. The JOS 
   website suggests reading ibm-vga.txt. They use port 0x3d4 and 0x3d5 for 
   the CRT control registers. This is documented in Ralf Brown's interrupt list
   file PORTS.B. Reading that in conjuction with ibm-vga.txt will help one 
   understand what is going on.

Caveat: The JOS initialisation routine takes care of monochrome as well as colour
   ports for video memory. My program assumes VGA and hardcodes 0xb8000 and 0x3d4
   as the ports. 
-------------------------------------------------------

------------------------------------------------------
Makefile Target: gas_boot
Source Files: prin-v0.asm prin2-part2.gas
Objective: Rewrite the same program as above, but in the GNU as
format. The linux kernel uses this format

Note: prin-v0.asm is still compiled with nasm, only prin2-part2.gas is compiled
with as. 

Learnings: 
	1. (I think at least) You cannot create a binary file
	   directly using as, instead you need to use the linker ld for that and give --oformat=binary
	2. -Ttext = 0x0 sets the executable address for the program 
	3. I am loading the program (2nd stage) at 0x10000, 
	   so why does it work if the linker is told to generate code at 0x0 ? 
	   Because the first few lines in my program load ax with cs address and
	   then dumps that to all the segment registers. Hence all memory loads
	   will be with respect to ds:mem_reference 
	   = 0x1000 x 16 + mem_reference 
	4. I should have mentioned this in the previous entry but notice the bug 
	   corrected in scroll_screen. es and ds are both loaded with 0xb800 
	   when scrolling the screen. Towards the end I want to update the
	   cursor position. But the ds register still points to 0xb800. I have
	   to load ds with 0x1000 and then do the mov [cursor_pos], di 
------------------------------------------------------
